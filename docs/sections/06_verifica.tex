\section{Verifica}
Ci sono varie verifiche che si possono fare andando a controllare se tutta una serie di caratteristiche volute si riflettano veramente nel modello simulativo costruito e quindi nei risultati ottenuti. In particolare, andrò ad effettuare le seguenti verifiche:
\begin{itemize}
    \item Verifica del corretto funzionamento di routing basato su soglia si \(SI_{max}\).
    \begin{itemize}
        \item Controllo che impostando \(SI_{max}=0\) venga utilizzato solo lo spike server.
        \item Controllo che impostando \(SI_{max}=\infty\) non venga mai utilizzato lo spike server.
    \end{itemize}
    \item Verifica delle metriche prestazionali:
    \begin{itemize}
        \item Verifico che aumentando \(SI_{max}\) l'utilizzazione del web server aumenta
        \item Verifico che il throughput sia pari al tasso di arrivo quando il sistema è stabile e uguale al tasso di servizio quando il sistema è sovraccarico.
    \end{itemize}
    % \item Verifica leggi operazionali
    % \begin{itemize}
    %     \item Verifica della legge di little: \(E[N] = \lambda E[R]\)
    % \end{itemize}
    % \item Verifica della distribuzione
    % \begin{itemize}
    %     \item Verifica che media e cv della distribuzione iperesponenziale corrispondano ai valori impostati.
    % \end{itemize}
\end{itemize}
    
\subsection{Verifica del routing basato su soglia \(SI_{max}\)}
\subsubsection{Verifica con \(SI_{max}=0\)}
Impostando \(SI_{max}=0\) si può verificare che tutti i job vengano instradati allo spike server. Infatti, come mostrato in figura \ref{fig:verifica_si_0}, l'utilizzazione del web server è nulla, mentre tutto il carico viene gestito dallo spike server.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/verifica_si_0.png}
    \caption{Verifica routing con \(SI_{max}=0\)}
    \label{fig:verifica_si_0}
\end{figure}
\subsubsection{Verifica con \(SI_{max}=\infty\)}
Impostando \(SI_{max}=\infty\) si può verificare che nessun job venga instradato allo spike server. Infatti, come mostrato in figura \ref{fig:verifica_si_inf}, l'utilizzazione dello spike server è nulla, mentre tutto il carico viene gestito dal web server.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/verifica_si_inf.png}
    \caption{Verifica routing con \(SI_{max}=\infty\)}
    \label{fig:verifica_si_inf}
\end{figure}

\subsection{Verifica delle metriche prestazionali}
\subsubsection{Verifica dell'utilizzazione al variare di \(SI_{max}\)}
Impostando un carico di lavoro fisso e variando il valore di \(SI_{max}\), si può verificare che l'utilizzazione del web server aumenti al crescere di \(SI_{max}\), come mostrato in figura \ref{fig:verifica_utilizzazione_si}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/verifica_utilizzazione_si.png}
    \caption{Verifica dell'utilizzazione del web server al variare di \(SI_{max}\)}
    \label{fig:verifica_utilizzazione_si}
\end{figure}

\begin{table}[H]
  \begin{center}
    \caption{Verifica dell'utilizzazione del web server al variare di \(SI_{max}\)}
    \pgfplotstabletypeset[
      multicolumn names, % allows to have multicolumn names
      col sep=comma, % the seperator in our .csv file
      display columns/0/.style={
        column name={$SI_{max}$},
        column type={S[round-mode=places, round-precision=0]},string type},  % use siunitx for formatting
      display columns/1/.style={
        column name={$\text{U}_{web}$},
        column type={S[round-mode=places, round-precision=4]},string type},
      display columns/2/.style={
        column name={$\text{U}_{web}$ CI95},
        column type={S[round-mode=places, round-precision=4]},string type},
      every head row/.style={
        before row={\toprule}, % have a rule at top
        after row={\midrule}, % rule under units
            },
        every last row/.style={after row=\bottomrule}, % rule at bottom
    ]{data_tables/graph_data_si_max.csv} % filename/path to file
  \end{center}
\end{table}

\subsubsection{Verifica del throughput}
Variando il carico di lavoro da 1 req/s a 12 req/s e impostando \(SI_{max} = \infty\), in modo da misurare solo il web server, si può verificare che il throughput del sistema non superi mai il suo limite teorico, che nel caso considerato è uguale a \(\min(\mu_{web}, \lambda_{web})\). Tuttavia, come evidenziato in Figura 6, il throughput misurato \(X_{measured} = N_{completed} / T_{sim}\) supera il limite teorico in condizioni di sovraccarico \((\rho>1)\). L'analisi di questa anomalia ha identificato la causa nella gestione della fine della simulazione (stopping condition).

Il protocollo di simulazione adottato, per mantenere stretta aderenza al caso di studio di riferimento, interrompe la simulazione a  \(T_{stop}=1200s\) senza attendere lo svuotamento delle code. Questa scelta metodologica introduce un bias sistematico quando il sistema è instabile:
\begin{itemize}
  \item Il calcolo del throughput considera solo i job completati entro $T_{stop}$.
  \item A causa della distribuzione iperesponenziale dei servizi (cv=4), i job con richieste di servizio brevi tendono a completare rapidamente, mentre i job con richieste lunghe ("heavy tail") tendono ad accumularsi in coda e rimanere incompleti allo scadere del tempo.
\end{itemize}

  Di conseguenza, il rapporto tra job completati e tempo trascorso risulta sovrastimato rispetto alla capacità reale del server di smaltire lavoro medio.



\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/wrong_throughput.png}
    \caption{Throughput misurato che supera il valore teorico}
    \label{fig:wrong_throughput}
\end{figure}

Sebbene si sia scelto di mantenere questo approccio per garantire la comparabilità dei risultati con il report originale, è fondamentale notare che il simulatore si comporta correttamente se si considera la relazione fondamentale:

\[ X_{calculated} = U_{web} \cdot \mu_{web} \]

Come mostrato in Figura \ref{fig:correct_throughput} e nella Tabella \ref{tab:verifica_throughput2}, il throughput calcolato a partire dall'utilizzazione ($X_{\text{calculated}}$) rispetta perfettamente il limite teorico, confermando che la logica interna del simulatore è corretta e che la discrepanza in Figura 6 è un artefatto della metrica di misurazione scelta dallo studio di riferimento, non un errore implementativo.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{images/correct_throughput.png}
    \caption{Throughput calcolato a partire dall'utilizzazione}
    \label{fig:correct_throughput}
\end{figure}

\begin{table}[H]
  \begin{center}
    \caption{Verifica del Throughput}
    \label{tab:verifica_throughput2}
    \pgfplotstabletypeset[
      multicolumn names, % allows to have multicolumn names
      col sep=comma, % the seperator in our .csv file
      display columns/0/.style={
        column name={$\lambda$},
        column type={S[round-mode=places, round-precision=0]},string type},  % use siunitx for formatting
      display columns/1/.style={
        column name={$X_{measured}$},
        column type={S[round-mode=places, round-precision=4]},string type},
      display columns/2/.style={
        column name={$X_{measured}$ CI95},
        column type={S[round-mode=places, round-precision=4]},string type},
      display columns/3/.style={
        column name={$X_{theoretical}$},
        column type={S[round-mode=places, round-precision=4]},string type
        },
      display columns/4/.style={
        column name={$X_{calculated}$},
        column type={S[round-mode=places, round-precision=4]},string type
        },
      display columns/5/.style={
        column name={$X_{calculated}$ CI95},
        column type={S[round-mode=places, round-precision=4]},string type
        },
      every head row/.style={
        column name={},
        before row={\toprule}, % have a rule at top
        after row={\midrule}, % rule under units
            },
        every last row/.style={after row=\bottomrule}, % rule at bottom
    ]{data_tables/data_throughput_si_max_inf.csv} % filename/path to file
  \end{center}
\end{table}